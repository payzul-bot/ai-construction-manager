# AI Construction Platform — Architecture

## 1. Назначение документа

Этот документ фиксирует **архитектурные границы платформы** и является
обязательным к соблюдению при разработке.

Цель:
- защитить ядро от размывания,
- исключить “умные” решения в интерфейсе,
- обеспечить воспроизводимость расчётов,
- позволить масштабировать платформу через данные, а не переписывание кода.

Если решение противоречит этому документу — **решение считается неверным**.

---

## 2. Главный архитектурный принцип

> **Ядро считает. Интерфейс спрашивает и показывает.**

Из этого следуют ключевые запреты:
- LLM **не считает**
- LLM **не добавляет работы, материалы или инструменты**
- UI **не принимает решений**
- Импорт **не меняет технологию**
- Любое изменение входа или правил → **новая версия результата**

---

## 3. Big-tech подход (почему так)

Платформа строится по принципу крупных инфраструктурных систем:

- код ядра меняется редко;
- новые сценарии добавляются через **конфигурации и данные**;
- доменная логика не размазывается по UI и AI.

Аналогия:
- Stripe добавляет способы оплаты без переписывания ядра;
- Uber добавляет новые сервисы поверх маршрутизации;
- здесь — новые виды работ добавляются через `CalculationProfile`.

---

## 4. Слои архитектуры (строгое разделение)

### Layer 0 — Core Engine (неприкосновенное ядро)

**Ответственность:**
- детерминированный расчёт;
- применение формул, норм и коэффициентов;
- агрегация итогов;
- контроль целостности;
- версионирование;
- audit trail.

**Запреты:**
- никаких текстовых интерпретаций;
- никаких UX-решений;
- никаких AI-вызовов.

Ядро получает **структурированный вход** и возвращает **структурированный результат**.

---

### Layer 1 — Domain Abstractions (универсальные сущности)

Этот слой одинаков для всех рынков и видов работ.

Ключевые абстракции:
- `Project` — контейнер проекта и его профиля;
- `WorkUnit` — универсальный атом работы;
- `CalculationProfile` — конфигурация расчёта;
- `RuleEngine` — применение правил;
- `Resource` — материал / инструмент / оборудование;
- `Estimate / EstimateVersion` — версия результата.

**Важно:**  
В коде нет “покраски стен”, “плитки” или “электрики” — только абстракции.

---

### Layer 2 — Configuration & Data Layer

Здесь находится всё предметное знание, но **в виде данных**:

- канонические справочники (WorkLeaf, Materials, Tools);
- паспорта Leaf-работ;
- нормы, формулы, BOM;
- правила включения, запреты, QC;
- региональные rule packs.

Добавление новой работы = добавление данных, **не изменение кода**.

---

### Layer 3 — Orchestration Layer

Отвечает за сборку проекта как системы работ:

- формирование списка WorkUnit;
- определение порядка выполнения;
- учёт зависимостей;
- выявление блокировок и условий.

Результат:
- технологически корректный план работ,
- готовый для расчёта ядром.

---

### Layer 4 — Interface Layer (UI / API / LLM)

**Назначение:**
- собрать ввод,
- задать уточняющие вопросы,
- отрендерить результат ядра.

**Состав:**
- текстовое поле (Base44-подход);
- wizard “Создать проект”;
- API;
- LLM как вспомогательный слой.

**Жёсткие ограничения для LLM:**
- нельзя добавлять позиции;
- нельзя менять расчёт;
- нельзя нарушать канонические названия;
- нельзя обходить QC и запреты.

LLM работает **поверх результата ядра**, а не вместо него.

---

### Layer 5 — Data & Audit Layer (Moat)

Этот слой аккумулирует ценность:

- входные параметры;
- исправления пользователя;
- выявленные риски;
- итоговые расчёты;
- версии и диффы;
- фактические результаты (в перспективе).

Этот слой:
- улучшает качество норм,
- усиливает доверие,
- формирует data moat.

---

## 5. Детерминированность и воспроизводимость

Обязательные условия:
- одинаковый ввод → одинаковый результат;
- результат не зависит от формулировки текста;
- результат не зависит от времени или пользователя.

Любая из этих ситуаций **недопустима**:
- “в этот раз посчиталось иначе”;
- “AI предложил ещё один материал”;
- “пользователь написал по-другому — список изменился”.

---

## 6. Версионирование

Версионируется **всё, что влияет на результат**:
- входные параметры;
- правила;
- нормы;
- конфигурации профилей.

Принцип:
> Нельзя «исправить» расчёт — можно только создать новую версию.

Старая версия остаётся доступной для:
- сравнения;
- аудита;
- разрешения споров.

---

## 7. Импорт данных (архитектурная роль)

Импорт:
- Excel,
- инженерные файлы,
- схемы,
- замеры,

является **источником предварительного ввода**, но не истины.

Правила:
- все импортированные данные требуют подтверждения;
- импорт не может отменить QC;
- импорт не может добавлять запрещённые работы.

---

## 8. Канонические идентификаторы

Внутренняя логика работает **только с ID**, а не с текстом.

Примеры:
- `work_id = paint_walls_putty`
- `material_id = primer_universal`

Текст — это слой представления.

Это правило:
- устраняет дубли;
- обеспечивает сравнимость данных;
- защищает расчёты от “плавающих формулировок”.

---

## 9. Что категорически запрещено

- считать или выбирать материалы в UI;
- позволять LLM «улучшать» расчёт;
- хранить бизнес-логику в контроллерах;
- хардкодить названия работ и материалов;
- изменять расчёт без создания версии;
- принимать импорт без валидации.

---

## 10. Как архитектура масштабируется

| Изменение | Что меняется |
|---------|-------------|
| Новый вид работ | Новый CalculationProfile |
| Новый регион | RulePack региона |
| Новый класс качества | Конфигурация качества |
| Новый материал | Запись Resource |
| Новый UX | Interface Layer |
| Новый AI | Interface Layer |

**Core Engine остаётся неизменным.**

---

## 11. Архитектурная цель

Построить систему, в которой:
- рост функциональности идёт через данные;
- логика не размазывается;
- ошибки можно объяснить;
- решения можно проверить и воспроизвести.

Это фундамент платформы, а не фичи.

---

## 12. Статус документа

Этот документ:
- обязателен для соблюдения;
- изменяется редко;
- любые изменения требуют отдельного обсуждения и версии.

